1. Course Schedule
題目：判斷是否能完成所有課程（檢查有無循環）

js
複製
編輯
function canFinish(numCourses, prerequisites) {
    const graph = Array.from({ length: numCourses }, () => []);
    const visited = new Array(numCourses).fill(0); // 0: 未訪問, 1: 訪問中, 2: 已完成

    for (const [a, b] of prerequisites) {
        graph[b].push(a);
    }

    function dfs(course) {
        if (visited[course] === 1) return false;
        if (visited[course] === 2) return true;

        visited[course] = 1;
        for (const next of graph[course]) {
            if (!dfs(next)) return false;
        }
        visited[course] = 2;
        return true;
    }

    for (let i = 0; i < numCourses; i++) {
        if (!dfs(i)) return false;
    }

    return true;
}
🔍 範例：numCourses = 2, prerequisites = [[1,0]] ➜ 可以完成 ➜ true

2. Implement Trie (Prefix Tree)
題目：實作一個字首樹 Trie

js
複製
編輯
class TrieNode {
    constructor() {
        this.children = {};
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let node = this.root;
        for (const c of word) {
            if (!node.children[c]) node.children[c] = new TrieNode();
            node = node.children[c];
        }
        node.isEnd = true;
    }

    search(word) {
        let node = this.root;
        for (const c of word) {
            if (!node.children[c]) return false;
            node = node.children[c];
        }
        return node.isEnd;
    }

    startsWith(prefix) {
        let node = this.root;
        for (const c of prefix) {
            if (!node.children[c]) return false;
            node = node.children[c];
        }
        return true;
    }
}
🔍 範例：插入 "apple"，查詢 "app" ➜ startsWith("app") = true, search("app") = false

3. Coin Change
題目：給定硬幣面額與總金額，求最少硬幣數量

js
複製
編輯
function coinChange(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (i - coin >= 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
}
🔍 範例：coins = [1,2,5], amount = 11 ➜ 用 5+5+1，最少 3 枚 ➜ 回傳 3

4. Product of Array Except Self
題目：輸出每個位置的乘積（不含自身，不能用除法）

js
複製
編輯
function productExceptSelf(nums) {
    const res = new Array(nums.length).fill(1);
    let left = 1, right = 1;

    for (let i = 0; i < nums.length; i++) {
        res[i] *= left;
        left *= nums[i];
    }

    for (let i = nums.length - 1; i >= 0; i--) {
        res[i] *= right;
        right *= nums[i];
    }

    return res;
}
🔍 範例：[1,2,3,4] ➜ 輸出 [24,12,8,6]

5. Min Stack
題目：支援 push/pop/top/getMin，並取得最小值

js
複製
編輯
class MinStack {
    constructor() {
        this.stack = [];
        this.minStack = [];
    }

    push(val) {
        this.stack.push(val);
        const min = this.minStack.length === 0 ? val : Math.min(val, this.getMin());
        this.minStack.push(min);
    }

    pop() {
        this.stack.pop();
        this.minStack.pop();
    }

    top() {
        return this.stack[this.stack.length - 1];
    }

    getMin() {
        return this.minStack[this.minStack.length - 1];
    }
}
🔍 範例：push(2), push(0), push(3), getMin() ➜ 回傳 0

6. Validate Binary Search Tree
題目：檢查是否為合法 BST（左小右大）

js
複製
編輯
function isValidBST(root) {
    function helper(node, min, max) {
        if (!node) return true;
        if ((min !== null && node.val <= min) || (max !== null && node.val >= max)) return false;
        return helper(node.left, min, node.val) && helper(node.right, node.val, max);
    }
    return helper(root, null, null);
}
🔍 範例：[2,1,3] 是合法 BST ➜ 回傳 true

7. Number of Islands
題目：統計 1 的群組數（"島"）

js
複製
編輯
function numIslands(grid) {
    const rows = grid.length, cols = grid[0].length;
    let count = 0;

    function dfs(i, j) {
        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] !== '1') return;
        grid[i][j] = '0';
        dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1);
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '1') {
                dfs(i, j);
                count++;
            }
        }
    }
    return count;
}
🔍 範例：[["1","1","0"],["0","1","0"],["0","0","1"]] ➜ 有 2 座島

8. Rotting Oranges
題目：每分鐘鄰近的橘子會爛，計算全部爛掉所需時間

js
複製
編輯
function orangesRotting(grid) {
    const rows = grid.length, cols = grid[0].length;
    const queue = [];
    let fresh = 0, minutes = 0;

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (grid[r][c] === 2) queue.push([r, c]);
            if (grid[r][c] === 1) fresh++;
        }
    }

    const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
    while (queue.length && fresh) {
        let size = queue.length;
        while (size--) {
            const [r, c] = queue.shift();
            for (const [dr, dc] of dirs) {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === 1) {
                    grid[nr][nc] = 2;
                    queue.push([nr, nc]);
                    fresh--;
                }
            }
        }
        minutes++;
    }

    return fresh === 0 ? minutes : -1;
}
🔍 範例：[[2,1,1],[1,1,0],[0,1,1]] ➜ 全爛需 4 分鐘