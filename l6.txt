1. Word Break
題目：判斷字串是否可以由字典中單字組成

js
複製
編輯
function wordBreak(s, wordDict) {
    const wordSet = new Set(wordDict);
    const dp = Array(s.length + 1).fill(false);
    dp[0] = true;

    for (let i = 1; i <= s.length; i++) {
        for (let j = 0; j < i; j++) {
            if (dp[j] && wordSet.has(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[s.length];
}
🔍 範例：s = "leetcode", wordDict = ["leet", "code"] ➜ 回傳 true

2. Partition Equal Subset Sum
題目：判斷是否能將陣列分成和相等的兩半

js
複製
編輯
function canPartition(nums) {
    const sum = nums.reduce((a, b) => a + b, 0);
    if (sum % 2 !== 0) return false;
    const target = sum / 2;
    const dp = Array(target + 1).fill(false);
    dp[0] = true;

    for (const num of nums) {
        for (let i = target; i >= num; i--) {
            dp[i] = dp[i] || dp[i - num];
        }
    }

    return dp[target];
}
🔍 範例：[1,5,11,5] ➜ 可以分成 [1,5,5] 和 [11] ➜ 回傳 true

3. String to Integer (atoi)
題目：實作 atoi() 功能：字串轉整數

js
複製
編輯
function myAtoi(s) {
    s = s.trim();
    const match = s.match(/^([+-]?\d+)/);
    if (!match) return 0;

    const num = parseInt(match[0], 10);
    return Math.max(Math.min(num, 2**31 - 1), -(2**31));
}
🔍 範例：s = " -42" ➜ 回傳 -42

4. Spiral Matrix
題目：按螺旋順序輸出 2D 矩陣

js
複製
編輯
function spiralOrder(matrix) {
    const result = [];
    let top = 0, bottom = matrix.length - 1;
    let left = 0, right = matrix[0].length - 1;

    while (top <= bottom && left <= right) {
        for (let i = left; i <= right; i++) result.push(matrix[top][i]);
        top++;
        for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);
        right--;
        if (top <= bottom) {
            for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);
            bottom--;
        }
        if (left <= right) {
            for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);
            left++;
        }
    }

    return result;
}
🔍 範例：[[1,2,3],[4,5,6],[7,8,9]] ➜ 回傳 [1,2,3,6,9,8,7,4,5]

5. Subsets
題目：輸出所有子集

js
複製
編輯
function subsets(nums) {
    const result = [];

    function backtrack(start, path) {
        result.push([...path]);
        for (let i = start; i < nums.length; i++) {
            path.push(nums[i]);
            backtrack(i + 1, path);
            path.pop();
        }
    }

    backtrack(0, []);
    return result;
}
🔍 範例：[1,2,3] ➜ 回傳所有子集如 [],[1],[1,2],[1,2,3]...

6. Binary Tree Right Side View
題目：輸出從右邊看二元樹的節點值

js
複製
編輯
function rightSideView(root) {
    const result = [];
    if (!root) return result;

    const queue = [root];
    while (queue.length) {
        const size = queue.length;
        for (let i = 0; i < size; i++) {
            const node = queue.shift();
            if (i === size - 1) result.push(node.val);
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
    }

    return result;
}
🔍 範例：[1,2,3,null,5,null,4] ➜ 回傳 [1,3,4]

7. Longest Palindromic Substring
題目：找出最長的回文子字串

js
複製
編輯
function longestPalindrome(s) {
    let res = "";

    function expand(left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            left--; right++;
        }
        return s.slice(left + 1, right);
    }

    for (let i = 0; i < s.length; i++) {
        const odd = expand(i, i);
        const even = expand(i, i + 1);
        if (odd.length > res.length) res = odd;
        if (even.length > res.length) res = even;
    }

    return res;
}
🔍 範例："babad" ➜ 回傳 "bab" 或 "aba"

8. Unique Paths
題目：計算從左上到右下的不同路徑數

js
複製
編輯
function uniquePaths(m, n) {
    const dp = Array(m).fill().map(() => Array(n).fill(1));

    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
}
🔍 範例：m = 3, n = 7 ➜ 回傳 28

9. Construct Binary Tree from Preorder and Inorder Traversal
題目：由先序與中序重建二元樹

js
複製
編輯
function buildTree(preorder, inorder) {
    if (!preorder.length || !inorder.length) return null;

    const rootVal = preorder.shift();
    const root = new TreeNode(rootVal);
    const idx = inorder.indexOf(rootVal);

    root.left = buildTree(preorder, inorder.slice(0, idx));
    root.right = buildTree(preorder, inorder.slice(idx + 1));

    return root;
}
🔍 範例：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] ➜ 重建正確的二元樹