1. Kth Smallest Element in a BST (Medium)
✅ BST 中第 K 小的元素

js
複製
編輯
function kthSmallest(root, k) {
    let count = 0, result = null;

    function inorder(node) {
        if (!node || result !== null) return;
        inorder(node.left);
        count++;
        if (count === k) result = node.val;
        inorder(node.right);
    }

    inorder(root);
    return result;
}
🔍 範例：[3,1,4,null,2], k = 1 ➜ 回傳 1

2. Minimum Window Substring (Hard)
✅ 找最小的子字串，包含所有 target 字元

js
複製
編輯
function minWindow(s, t) {
    if (!s || !t) return "";

    let map = {};
    for (let c of t) map[c] = (map[c] || 0) + 1;

    let start = 0, end = 0, minLen = Infinity, minStart = 0, counter = t.length;

    while (end < s.length) {
        if (map[s[end]]-- > 0) counter--;
        end++;

        while (counter === 0) {
            if (end - start < minLen) {
                minLen = end - start;
                minStart = start;
            }
            if (++map[s[start]] > 0) counter++;
            start++;
        }
    }

    return minLen === Infinity ? "" : s.slice(minStart, minStart + minLen);
}
🔍 範例：s = "ADOBECODEBANC", t = "ABC" ➜ 回傳 "BANC"

3. Serialize and Deserialize Binary Tree (Hard)
✅ 將二元樹序列化與反序列化

js
複製
編輯
class Codec {
    serialize(root) {
        const res = [];
        function dfs(node) {
            if (!node) {
                res.push("null");
                return;
            }
            res.push(node.val);
            dfs(node.left);
            dfs(node.right);
        }
        dfs(root);
        return res.join(",");
    }

    deserialize(data) {
        const vals = data.split(",");
        let i = 0;

        function build() {
            if (vals[i] === "null") {
                i++;
                return null;
            }
            const node = new TreeNode(parseInt(vals[i++]));
            node.left = build();
            node.right = build();
            return node;
        }

        return build();
    }
}
🔍 範例：輸入為樹 [1,2,3,null,null,4,5] ➜ 序列化為 "1,2,null,null,3,4,null,null,5,null,null"

4. Trapping Rain Water (Hard)
✅ 接雨水：找可存水區域總量

js
複製
編輯
function trap(height) {
    let left = 0, right = height.length - 1;
    let leftMax = 0, rightMax = 0, res = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            leftMax = Math.max(leftMax, height[left]);
            res += leftMax - height[left];
            left++;
        } else {
            rightMax = Math.max(rightMax, height[right]);
            res += rightMax - height[right];
            right--;
        }
    }

    return res;
}
🔍 範例：[0,1,0,2,1,0,1,3,2,1,2,1] ➜ 回傳 6

5. Find Median from Data Stream (Hard)
✅ 動態加入數據並找中位數

js
複製
編輯
class MedianFinder {
    constructor() {
        this.small = [], this.large = [];
    }

    addNum(num) {
        this.small.push(num);
        this.small.sort((a, b) => b - a);

        this.large.push(this.small.shift());
        this.large.sort((a, b) => a - b);

        if (this.small.length < this.large.length) {
            this.small.push(this.large.shift());
        }
    }

    findMedian() {
        if (this.small.length > this.large.length) return this.small[0];
        return (this.small[0] + this.large[0]) / 2;
    }
}
🔍 範例：輸入 [1,2]，呼叫 findMedian() ➜ 回傳 1.5

6. Word Ladder (Hard)
✅ 最短轉換序列（BFS）

js
複製
編輯
function ladderLength(beginWord, endWord, wordList) {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;

    let queue = [[beginWord, 1]];

    while (queue.length) {
        const [word, len] = queue.shift();
        if (word === endWord) return len;

        for (let i = 0; i < word.length; i++) {
            for (let c = 97; c <= 122; c++) {
                const next = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);
                if (wordSet.has(next)) {
                    queue.push([next, len + 1]);
                    wordSet.delete(next);
                }
            }
        }
    }

    return 0;
}
🔍 範例："hit" -> "cog" ➜ 回傳 5（"hit"→"hot"→"dot"→"dog"→"cog"）

7. Basic Calculator (Hard)
✅ 實作含括號的加減運算

js
複製
編輯
function calculate(s) {
    let stack = [], num = 0, sign = 1, result = 0;

    for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (!isNaN(c) && c !== ' ') {
            num = num * 10 + parseInt(c);
        } else if (c === '+') {
            result += sign * num;
            num = 0;
            sign = 1;
        } else if (c === '-') {
            result += sign * num;
            num = 0;
            sign = -1;
        } else if (c === '(') {
            stack.push(result);
            stack.push(sign);
            result = 0;
            sign = 1;
        } else if (c === ')') {
            result += sign * num;
            result *= stack.pop();
            result += stack.pop();
            num = 0;
        }
    }

    return result + sign * num;
}
🔍 範例："(1+(4+5+2)-3)+(6+8)" ➜ 回傳 23

8. Maximum Profit in Job Scheduling (Hard)
✅ 排程不重疊工作使利潤最大（DP + binary search）

js
複製
編輯
function jobScheduling(startTime, endTime, profit) {
    const jobs = startTime.map((s, i) => [s, endTime[i], profit[i]])
                          .sort((a, b) => a[1] - b[1]);

    const dp = [[0, 0]];

    for (let [s, e, p] of jobs) {
        let l = 0, r = dp.length;
        while (l < r) {
            const m = Math.floor((l + r) / 2);
            if (dp[m][0] <= s) l = m + 1;
            else r = m;
        }
        const prevProfit = dp[l - 1][1];
        const currProfit = prevProfit + p;
        if (currProfit > dp[dp.length - 1][1]) {
            dp.push([e, currProfit]);
        }
    }

    return dp[dp.length - 1][1];
}
🔍 範例：[1,2,3,3], [3,4,5,6], [50,10,40,70] ➜ 回傳 120

9. Merge k Sorted Lists (Hard)
✅ 合併 k 個排序連結串列

js
複製
編輯
function mergeKLists(lists) {
    const mergeTwo = (l1, l2) => {
        let dummy = new ListNode(0), curr = dummy;
        while (l1 && l2) {
            if (l1.val < l2.val) [curr.next, l1] = [l1, l1.next];
            else [curr.next, l2] = [l2, l2.next];
            curr = curr.next;
        }
        curr.next = l1 || l2;
        return dummy.next;
    };

    while (lists.length > 1) {
        const merged = [];
        for (let i = 0; i < lists.length; i += 2) {
            merged.push(mergeTwo(lists[i], lists[i + 1] || null));
        }
        lists = merged;
    }

    return lists[0] || null;
}
🔍 範例：[[1,4,5],[1,3,4],[2,6]] ➜ 回傳 [1,1,2,3,4,4,5,6]

10. Largest Rectangle in Histogram (Hard)
✅ 找柱狀圖中最大矩形面積（單調棧）

js
複製
編輯
function largestRectangleArea(heights) {
    heights.push(0);
    let stack = [], max = 0;

    for (let i = 0; i < heights.length; i++) {
        while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {
            const height = heights[stack.pop()];
            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
            max = Math.max(max, height * width);
        }
        stack.push(i);
    }

    return max;
}
🔍 範例：[2,1,5,6,2,3] ➜ 回傳 10