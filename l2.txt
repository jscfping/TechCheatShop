1. First Bad Version
題目：給定一系列版本，找出第一個壞的版本

js
複製
編輯
var solution = function(isBadVersion) {
    return function(n) {
        let left = 1, right = n;
        while (left < right) {
            let mid = Math.floor((left + right) / 2);
            if (isBadVersion(mid)) right = mid;
            else left = mid + 1;
        }
        return left;
    };
};
🔍 範例：n = 5, isBadVersion(4) = true，第一個壞版本是 4

2. Ransom Note
題目：能否用雜誌字母拼出勒索信

js
複製
編輯
function canConstruct(ransomNote, magazine) {
    const count = {};
    for (let c of magazine) count[c] = (count[c] || 0) + 1;
    for (let c of ransomNote) {
        if (!count[c]) return false;
        count[c]--;
    }
    return true;
}
🔍 範例：ransomNote = "aa", magazine = "aab" ➜ true

3. Climbing Stairs
題目：爬樓梯，每次爬 1 或 2 階，求總走法

js
複製
編輯
function climbStairs(n) {
    let a = 1, b = 1;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b];
    }
    return b;
}
🔍 範例：n = 3 ➜ 有 3 種方式：1+1+1, 1+2, 2+1

4. Longest Palindrome
題目：找出可以組成的最長回文長度

js
複製
編輯
function longestPalindrome(s) {
    const set = new Set();
    let len = 0;
    for (let c of s) {
        if (set.has(c)) {
            set.delete(c);
            len += 2;
        } else {
            set.add(c);
        }
    }
    return len + (set.size ? 1 : 0);
}
🔍 範例："abccccdd" ➜ 可組成長度為 7（"dccaccd"）

5. Reverse Linked List
題目：反轉單向 linked list

js
複製
編輯
function reverseList(head) {
    let prev = null, curr = head;
    while (curr) {
        const next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
🔍 範例：1 → 2 → 3 ➜ 3 → 2 → 1

6. Majority Element
題目：出現次數超過一半的元素

js
複製
編輯
function majorityElement(nums) {
    let count = 0, candidate = null;
    for (let num of nums) {
        if (count === 0) candidate = num;
        count += (num === candidate) ? 1 : -1;
    }
    return candidate;
}
🔍 範例：[3, 2, 3] ➜ 3 是多數元素

7. Add Binary
題目：兩個二進位字串相加

js
複製
編輯
function addBinary(a, b) {
    let i = a.length - 1, j = b.length - 1, carry = 0, res = '';
    while (i >= 0 || j >= 0 || carry) {
        let sum = (a[i--] - 0 || 0) + (b[j--] - 0 || 0) + carry;
        res = (sum % 2) + res;
        carry = Math.floor(sum / 2);
    }
    return res;
}
🔍 範例：a = "11", b = "1" ➜ 回傳 "100"

8. Diameter of Binary Tree
題目：找出二元樹中任兩節點間最長路徑長度

js
複製
編輯
function diameterOfBinaryTree(root) {
    let diameter = 0;
    function dfs(node) {
        if (!node) return 0;
        const left = dfs(node.left);
        const right = dfs(node.right);
        diameter = Math.max(diameter, left + right);
        return Math.max(left, right) + 1;
    }
    dfs(root);
    return diameter;
}
🔍 範例：如 [1,2,3,4,5] ➜ 最長路徑是 4 → 2 → 1 → 3，長度 3

9. Middle of the Linked List
題目：回傳 linked list 中間節點

js
複製
編輯
function middleNode(head) {
    let slow = head, fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
🔍 範例：1 → 2 → 3 → 4 → 5 ➜ 中間是 3

10. Maximum Depth of Binary Tree
題目：找出二元樹最大深度

js
複製
編輯
function maxDepth(root) {
    if (!root) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
🔍 範例：[3,9,20,null,null,15,7] ➜ 深度為 3

11. Contains Duplicate
題目：判斷陣列是否有重複元素

js
複製
編輯
function containsDuplicate(nums) {
    const set = new Set();
    for (let num of nums) {
        if (set.has(num)) return true;
        set.add(num);
    }
    return false;
}
🔍 範例：[1,2,3,1] ➜ true

12. Maximum Subarray
題目：找出連續子陣列最大和（Kadane's Algorithm）

js
複製
編輯
function maxSubArray(nums) {
    let max = nums[0], sum = nums[0];
    for (let i = 1; i < nums.length; i++) {
        sum = Math.max(nums[i], sum + nums[i]);
        max = Math.max(max, sum);
    }
    return max;
}
🔍 範例：[-2,1,-3,4,-1,2,1,-5,4] ➜ 最大子陣列是 [4,-1,2,1] ➜ 和是 6

