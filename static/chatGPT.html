<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="#">
    <title>MyAIChat</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <style>
        .box {
            display: flex;
        }

        .half {
            width: 50%;
        }
    </style>
</head>

<body>
    <div id="app">
        apiKey<input v-model="apiKey"><br>
        <textarea cols="20" rows="5">gpt-4.1-nano
gpt-4.1-mini
gpt-4o-mini
gpt-4.1</textarea><br>
        <div class="box">
            <div class="half">
                model<input v-model="chatGPTData1.model"><br>
                temperature<input v-model="chatGPTData1.temperature"><br>
                max_tokens<input v-model="chatGPTData1.max_tokens"><br>
                top_p<input v-model="chatGPTData1.top_p"><br>
                frequency_penalty<input v-model="chatGPTData1.frequency_penalty"><br>
                presence_penalty<input v-model="chatGPTData1.presence_penalty"><br>
                system<br>
                <textarea cols="30" rows="5" v-model="chatGPTData1.headData[0].content[0].text"></textarea><br>
                inputMessage<br>
                <textarea cols="30" rows="5" v-model="chatGPTData1.inputMessage"></textarea>
                <template v-if="!chatGPTData1.loading">
                    <input type="button" value="send" @click="sendAsync(1)">
                </template>
                <template v-else>
                    <input type="button" value="loading" disabled>
                </template>
                <hr>
                <template v-for="(message, messageIdx) in chatGPTData1.messages" :key="messageIdx">
                    <textarea cols="30" rows="5" v-model="message.req"></textarea>
                    <textarea cols="30" rows="5" v-model="message.res" :ref="'respTextarea1'"></textarea><br>
                </template>
            </div>
            <div class="half">
                model<input v-model="chatGPTData2.model"><br>
                temperature<input v-model="chatGPTData2.temperature"><br>
                max_tokens<input v-model="chatGPTData2.max_tokens"><br>
                top_p<input v-model="chatGPTData2.top_p"><br>
                frequency_penalty<input v-model="chatGPTData2.frequency_penalty"><br>
                presence_penalty<input v-model="chatGPTData2.presence_penalty"><br>
                system<br>
                <textarea cols="30" rows="5" v-model="chatGPTData2.headData[0].content[0].text"></textarea><br>
                inputMessage<br>
                <textarea cols="30" rows="5" v-model="chatGPTData2.inputMessage"></textarea>
                <template v-if="!chatGPTData2.loading">
                    <input type="button" value="send" @click="sendAsync(2)">
                </template>
                <template v-else>
                    <input type="button" value="loading" disabled>
                </template>
                <hr>
                <template v-for="(message, messageIdx) in chatGPTData2.messages" :key="messageIdx">
                    <textarea cols="30" rows="5" v-model="message.req"></textarea>
                    <textarea cols="30" rows="5" v-model="message.res" :ref="'respTextarea2'"></textarea><br>
                </template>
            </div>
        </div>

    </div>
    <script>



        const vm = new Vue({
            el: "#app",
            data: {
                apiKey: "",
                chatGPTData1: {
                    headData: [
                        {
                            "role": "system",
                            "content": [
                                {
                                    "type": "text",
                                    "text": ""
                                }
                            ]
                        }
                    ],
                    model: "gpt-4.1-mini",
                    temperature: 0.8,
                    max_tokens: 8192,
                    top_p: 1,
                    frequency_penalty: 0,
                    presence_penalty: 0,
                    inputMessage: "",
                    messages: [],
                    loading: false
                },
                chatGPTData2: {
                    headData: [
                        {
                            "role": "system",
                            "content": [
                                {
                                    "type": "text",
                                    "text": ""
                                }
                            ]
                        }
                    ],
                    model: "gpt-4.1-mini",
                    temperature: 0.8,
                    max_tokens: 8192,
                    top_p: 1,
                    frequency_penalty: 0,
                    presence_penalty: 0,
                    inputMessage: "",
                    messages: [],
                    loading: false
                }
            },
            mounted() {
                const urlParams = new URLSearchParams(window.location.search);
                this.apiKey = urlParams.get("apiKey");
                const system1 = urlParams.get("system1");
                const system2 = urlParams.get("system2");
                if (system1) {
                    this.chatGPTData1.headData[0].content[0].text = system1;
                }
                if (system2) {
                    this.chatGPTData2.headData[0].content[0].text = system2;
                }
            },
            methods: {
                getAuthorization() {
                    return `Bearer ${this.apiKey}`;
                },
                scrollResponseToBottom(id) {
                    this.$nextTick(() => {
                        const refName = `respTextarea${id}`;
                        const textareaArray = this.$refs[refName];
                        if (textareaArray && textareaArray.length > 0) {
                            const textarea = textareaArray[0];
                            textarea.scrollTop = textarea.scrollHeight;
                        }
                    });
                },
                async sendAsync(id) {
                    const chatGPTData = id === 1 ? this.chatGPTData1 : this.chatGPTData2;

                    const req = chatGPTData.inputMessage;
                    chatGPTData.inputMessage = "";
                    chatGPTData.loading = true;

                    const reqData = {
                        model: chatGPTData.model,
                        messages: chatGPTData.headData.concat({
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: req
                                }
                            ]
                        }),
                        temperature: Number(chatGPTData.temperature),
                        max_tokens: Number(chatGPTData.max_tokens),
                        top_p: Number(chatGPTData.top_p),
                        frequency_penalty: Number(chatGPTData.frequency_penalty),
                        presence_penalty: Number(chatGPTData.presence_penalty),
                        stream: true
                    };

                    let fullResponse = "";

                    try {
                        const response = await fetch("https://api.openai.com/v1/chat/completions", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": this.getAuthorization()
                            },
                            body: JSON.stringify(reqData)
                        });

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();

                        const newMsg = {
                            req: req,
                            res: ""
                        };

                        chatGPTData.messages.unshift(newMsg);

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const text = decoder.decode(value);
                            const lines = text.split('\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') {
                                        break;
                                    }
                                    try {
                                        const json = JSON.parse(data);
                                        const content = json.choices[0]?.delta?.content || '';
                                        newMsg.res += content;
                                        if (json.choices[0]?.finish_reason) {
                                            newMsg.res += `
=====finish_reason=====
${json.choices[0]?.finish_reason}}`;
                                        }
                                        this.scrollResponseToBottom(id);
                                    } catch (e) {
                                        // ignore parse errors
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error("Error:", error);
                        chatGPTData.messages.unshift({
                            req: req,
                            res: `Error: ${error.message}`
                        });
                    } finally {
                        chatGPTData.loading = false;
                    }
                }
            }
        });
    </script>
</body>

</html>