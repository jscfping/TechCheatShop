1. Search in Rotated Sorted Array
題目：在旋轉排序陣列中搜尋目標值

js
複製
編輯
function search(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] === target) return mid;

        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) right = mid - 1;
            else left = mid + 1;
        } else {
            if (nums[mid] < target && target <= nums[right]) left = mid + 1;
            else right = mid - 1;
        }
    }
    return -1;
}
🔍 範例：nums = [4,5,6,7,0,1,2], target = 0 ➜ 回傳 4

2. Combination Sum
題目：找出所有可以組成目標總和的組合（可重複）

js
複製
編輯
function combinationSum(candidates, target) {
    const result = [];

    function backtrack(start, comb, total) {
        if (total === target) {
            result.push([...comb]);
            return;
        }
        if (total > target) return;

        for (let i = start; i < candidates.length; i++) {
            comb.push(candidates[i]);
            backtrack(i, comb, total + candidates[i]);
            comb.pop();
        }
    }

    backtrack(0, [], 0);
    return result;
}
🔍 範例：candidates = [2,3,6,7], target = 7 ➜ [ [2,2,3], [7] ]

3. Permutations
題目：回傳所有數字的排列組合（無重複）

js
複製
編輯
function permute(nums) {
    const result = [];

    function backtrack(path, used) {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            used[i] = true;
            path.push(nums[i]);
            backtrack(path, used);
            path.pop();
            used[i] = false;
        }
    }

    backtrack([], Array(nums.length).fill(false));
    return result;
}
🔍 範例：[1,2,3] ➜ 所有排列 ➜ [[1,2,3],[1,3,2],...]

4. Merge Intervals
題目：合併重疊區間

js
複製
編輯
function merge(intervals) {
    if (!intervals.length) return [];

    intervals.sort((a, b) => a[0] - b[0]);
    const result = [intervals[0]];

    for (let i = 1; i < intervals.length; i++) {
        const last = result[result.length - 1];
        if (intervals[i][0] <= last[1]) {
            last[1] = Math.max(last[1], intervals[i][1]);
        } else {
            result.push(intervals[i]);
        }
    }

    return result;
}
🔍 範例：[[1,3],[2,6],[8,10],[15,18]] ➜ [[1,6],[8,10],[15,18]]

5. Lowest Common Ancestor of a Binary Tree
題目：找二元樹中兩節點的最近共同祖先

js
複製
編輯
function lowestCommonAncestor(root, p, q) {
    if (!root || root === p || root === q) return root;

    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);

    if (left && right) return root;
    return left || right;
}
🔍 範例：在樹 [3,5,1,6,2,0,8,null,null,7,4] 中找 5 和 1 ➜ 回傳 3

6. Time Based Key-Value Store
題目：實作 set(key, value, timestamp) 和 get(key, timestamp)

js
複製
編輯
class TimeMap {
    constructor() {
        this.store = new Map();
    }

    set(key, value, timestamp) {
        if (!this.store.has(key)) {
            this.store.set(key, []);
        }
        this.store.get(key).push([timestamp, value]);
    }

    get(key, timestamp) {
        const vals = this.store.get(key) || [];
        let left = 0, right = vals.length - 1, res = "";

        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (vals[mid][0] <= timestamp) {
                res = vals[mid][1];
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return res;
    }
}
🔍 範例：set("foo","bar",1); get("foo",1) ➜ 回傳 "bar"

7. Accounts Merge
題目：合併同一人帳戶（根據 email）

js
複製
編輯
function accountsMerge(accounts) {
    const emailToName = {};
    const graph = {};

    for (const [name, ...emails] of accounts) {
        for (const email of emails) {
            emailToName[email] = name;
            if (!graph[email]) graph[email] = [];
        }
        for (let i = 1; i < emails.length; i++) {
            graph[emails[0]].push(emails[i]);
            graph[emails[i]].push(emails[0]);
        }
    }

    const visited = new Set();
    const result = [];

    function dfs(email, collected) {
        collected.push(email);
        visited.add(email);
        for (const nei of graph[email]) {
            if (!visited.has(nei)) dfs(nei, collected);
        }
    }

    for (const email in graph) {
        if (!visited.has(email)) {
            const collected = [];
            dfs(email, collected);
            result.push([emailToName[email], ...collected.sort()]);
        }
    }

    return result;
}
🔍 範例：兩個帳號都用 johnsmith@mail.com ➜ 會合併成一筆

8. Sort Colors
題目：對只有 0、1、2 的陣列排序（原地、一次遍歷）

js
複製
編輯
function sortColors(nums) {
    let low = 0, mid = 0, high = nums.length - 1;

    while (mid <= high) {
        if (nums[mid] === 0) {
            [nums[low], nums[mid]] = [nums[mid], nums[low]];
            low++; mid++;
        } else if (nums[mid] === 1) {
            mid++;
        } else {
            [nums[mid], nums[high]] = [nums[high], nums[mid]];
            high--;
        }
    }
}
🔍 範例：[2,0,2,1,1,0] ➜ 排成 [0,0,1,1,2,2]